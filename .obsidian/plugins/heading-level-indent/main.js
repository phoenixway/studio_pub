/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
__export(exports, {
  default: () => HeadingIndent
});
var import_obsidian2 = __toModule(require("obsidian"));

// src/readingMode.ts
var ShitIndenting = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.containerSelector = ".workspace-leaf.mod-active .markdown-reading-view .markdown-preview-section";
    this.arrClassesHeadings = {
      1: "heading_h1",
      2: "heading_h2",
      3: "heading_h3",
      4: "heading_h4",
      5: "heading_h5",
      6: "heading_h6"
    };
    this.arrClassesData = {
      0: "data_no-heading",
      1: "data_h1",
      2: "data_h2",
      3: "data_h3",
      4: "data_h4",
      5: "data_h5",
      6: "data_h6"
    };
  }
  setObserverToActiveLeaf(plugin) {
    if (this.previewObserver !== void 0) {
      this.previewObserver.disconnect();
    }
    const targetNode = activeDocument.querySelector(this.containerSelector);
    if (targetNode == null) {
      return;
    }
    const config = { childList: true };
    const callback = (mutationList, observer) => {
      for (const mutation of mutationList) {
        if (mutation.type === "childList") {
          this.applyIndent(plugin, 0, true, "mutation");
        }
      }
    };
    this.previewObserver = new MutationObserver(callback);
    this.previewObserver.observe(targetNode, config);
  }
  applyIndent(plugin, timeout, flag, text = "") {
    timeout = timeout || 0;
    if (timeout == 0 && flag === false) {
      this.applyIndentation(plugin);
      return;
    }
    if (flag) {
      if (this.flagExecute == void 0 || this.flagExecute == 1) {
        this.flagExecute = 2;
        setTimeout(() => {
          this.applyIndentation(plugin);
        }, timeout);
        setTimeout(() => {
          this.flagExecute = 1;
        }, timeout + 50);
      }
    } else {
      setTimeout(() => {
        this.applyIndentation(plugin);
      }, timeout);
    }
  }
  applyIndentation(plugin) {
    const settings = plugin.settings;
    const divsNodeList = activeDocument.querySelectorAll(this.containerSelector + " > div");
    if (!divsNodeList) {
      return;
    }
    const arrDivs = Array.from(divsNodeList);
    const excludedClassNames = ["mod-header", "mod-footer", "markdown-preview-pusher"];
    this.cleanSectionModifications(arrDivs);
    const arrMargins = {
      0: 0,
      1: parseInt(settings.h1) || 0,
      2: parseInt(settings.h2) || 0,
      3: parseInt(settings.h3) || 0,
      4: parseInt(settings.h4) || 0,
      5: parseInt(settings.h5) || 0,
      6: parseInt(settings.h6) || 0
    };
    let hNumber = 0;
    suck:
      for (const div of arrDivs) {
        if (excludedClassNames.some((className) => div.classList.contains(className))) {
          continue suck;
        }
        const headingNodeList = div.querySelectorAll("h1, h2, h3, h4, h5, h6"), currentDivIsHeading = headingNodeList.length > 0;
        if (currentDivIsHeading) {
          const hTag = headingNodeList[0].tagName.toLowerCase();
          hNumber = parseInt(hTag.replace(/^\D+/g, ""));
          div.style.marginLeft = arrMargins[hNumber - 1] + "px";
          div.classList.add(this.arrClassesHeadings[hNumber]);
        } else {
          div.style.marginLeft = arrMargins[hNumber] + "px";
          div.classList.add(this.arrClassesData[hNumber]);
        }
      }
  }
  cleanSectionModifications(arrDivs) {
    for (const div of arrDivs) {
      div.style.marginLeft = null;
      div.classList.forEach((item) => {
        if (item.startsWith("data_") || item.startsWith("heading_")) {
          div.classList.remove(item);
        }
      });
    }
  }
};

// src/settings.ts
var import_obsidian = __toModule(require("obsidian"));
var DEFAULT_SETTINGS = {
  h1: "30",
  h2: "50",
  h3: "70",
  h4: "90",
  h5: "110",
  h6: "130",
  enableReading: true,
  enableEditing: true
};
var IndentSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.displayGeneralSetting(containerEl);
    containerEl.createEl("h3", { text: "Set indentation for the content of each heading in pixels" });
    containerEl.createEl("div", {
      text: `Indentation applied for the heading lines itself will be the same as the
						content of inmediately previous heading. For example, if the indentation 
						for the content of H3 is set to 70 pixels, H2 heading line itself
						will be indented the same`,
      attr: { style: "margin-bottom: 10px; color: gray;" }
    });
    new import_obsidian.Setting(containerEl).setName("Content under H1").addText((number) => number.setPlaceholder("").setValue(this.plugin.settings.h1).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.h1 = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Content under H2").addText((text) => text.setPlaceholder("").setValue(this.plugin.settings.h2).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.h2 = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Content under H3").addText((text) => text.setPlaceholder("").setValue(this.plugin.settings.h3).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.h3 = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Content under H4").addText((text) => text.setPlaceholder("").setValue(this.plugin.settings.h4).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.h4 = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Content under H5").addText((text) => text.setPlaceholder("").setValue(this.plugin.settings.h5).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.h5 = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Content under H6").addText((text) => text.setPlaceholder("").setValue(this.plugin.settings.h6).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.h6 = value;
      yield this.plugin.saveSettings();
    })));
  }
  displayGeneralSetting(containerEl) {
    new import_obsidian.Setting(containerEl).setName("Enable in editing mode? (reload required)").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableEditing).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.enableEditing = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Enable in reading view?").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableReading).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.enableReading = value;
      yield this.plugin.saveSettings();
    })));
  }
};

// src/editingMode.ts
var import_language = __toModule(require("@codemirror/language"));
var import_state = __toModule(require("@codemirror/state"));
var import_view = __toModule(require("@codemirror/view"));
var indentStateField = import_state.StateField.define({
  create(state) {
    return getDecorationSet(state);
  },
  update(currentValue, tr) {
    if (!tr.docChanged)
      return currentValue;
    return getDecorationSet(tr.state);
  },
  provide(field) {
    return import_view.EditorView.decorations.from(field);
  }
});
function getDecorationSet(state) {
  var _a;
  const settings = window.app.plugins.plugins["heading-level-indent"].settings;
  const headings = [];
  const embeds = [];
  (0, import_language.syntaxTree)(state).iterate({
    enter(node) {
      if (node.type.name.startsWith("HyperMD-header_HyperMD-header-")) {
        const lineAt = state.doc.lineAt(node.from);
        const text = state.doc.sliceString(node.from, node.to);
        const level = Number(node.type.name.slice(-1));
        headings.push({
          text,
          level,
          headingLineNumber: lineAt.number
        });
      }
    }
  });
  const builder = new import_state.RangeSetBuilder();
  const el = document.querySelector(".workspace-leaf.mod-active .cm-content");
  if (el === null)
    return import_view.Decoration.none;
  const containerWidth = parseInt(getComputedStyle(el).width);
  for (const [index, heading] of headings.entries()) {
    const { level, headingLineNumber } = heading;
    const headingLine = state.doc.line(headingLineNumber);
    const firstDataLineNumber = headingLineNumber + 1;
    const lastDataLineNumber = ((_a = headings[index + 1]) == null ? void 0 : _a.headingLineNumber) - 1 || state.doc.lines;
    const pxForDataLine = settings[`h${level}`] || 0;
    const pxForHeadingLine = settings[`h${level - 1}` || 0];
    const dataStyles = `left:${pxForDataLine}px;width:${containerWidth - pxForDataLine}px`;
    const headingStyles = `left:${pxForHeadingLine}px;width:${containerWidth - pxForHeadingLine}px`;
    builder.add(headingLine.from, headingLine.from, import_view.Decoration.line({
      attributes: { style: headingStyles }
    }));
    for (let j = firstDataLineNumber; j < lastDataLineNumber + 1; j++) {
      const dataLine = state.doc.line(j);
      builder.add(dataLine.from, dataLine.from, import_view.Decoration.line({
        attributes: { style: dataStyles }
      }));
    }
  }
  return builder.finish();
}

// src/main.ts
var HeadingIndent = class extends import_obsidian2.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.addSettingTab(new IndentSettingTab(this.app, this));
      if (this.settings.enableReading)
        this.shitRunner();
      if (this.settings.enableEditing)
        this.registerEditorExtension(indentStateField);
    });
  }
  onunload() {
    this.shitCleaner();
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
      this.settings.enableReading ? this.shitRunner() : this.shitCleaner();
    });
  }
  shitRunner() {
    this.shitIndenting = new ShitIndenting(this);
    this.app.workspace.onLayoutReady(() => {
    });
    this.layoutChange = this.app.workspace.on("layout-change", () => {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
      if (!activeView || activeView.getViewType() !== "markdown") {
        return;
      }
      const view = activeView;
      const mode = view.getMode();
      if (mode == "preview") {
        this.shitIndenting.applyIndent(this, 0, false, "layout-change");
        this.shitIndenting.setObserverToActiveLeaf(this);
      }
    });
    this.activeLeafChangeListener = this.app.workspace.on("active-leaf-change", (leaf) => {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
      if (!activeView || activeView.getViewType() !== "markdown") {
        return;
      }
      const view = activeView;
      const mode = view.getMode();
      if (mode == "preview") {
        this.shitIndenting.applyIndent(this, 0, false, "active-leaf-change-1");
        this.shitIndenting.applyIndent(this, 200, false, "active-leaf-change-2");
        this.shitIndenting.setObserverToActiveLeaf(this);
      }
    });
  }
  shitCleaner() {
    this.shitIndenting && this.shitIndenting.previewObserver && this.shitIndenting.previewObserver.disconnect();
    this.app.workspace.offref(this.activeLeafChangeListener);
    this.app.workspace.offref(this.layoutChange);
  }
};


/* nosourcemap */